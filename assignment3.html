<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Data Structures and Algorithms with Python - Assignment - 3</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="data-structures-and-algorithms-with-python---assignment---3">Data Structures and Algorithms with Python - Assignment - 3</h1>
<p><strong>CDA 500</strong>
<strong>Vaibhav Bansal - 50560484</strong></p>
<h1 id="question-1">Question 1</h1>
<p><strong>Q1 -- Explain in your own words what a linked list is.</strong></p>
<p><strong>Answer 1:</strong></p>
<p>Linked lists are data structures that use nodes to organize information, with each node potentially scattered across different memory locations.This makes the data assignable to any number of memory blocks dynamically and, therefore, it makes its application very flexible. That flexibility may become an advantage for some tasks, in particular those where a large amount of insertions and deletions need to be done continuously. However, linked lists come with an efficiency trade-off, possibly at the cost of more memory and slower access time compared to arrays.</p>
<p>Linked Node -&gt; It has value and reference to the next node.</p>
<ul>
<li>Data: The value or data element the node contains (e.g., an integer, string, etc.).</li>
<li>Next: A reference (or pointer) to the next node in the list.</li>
</ul>
<pre><code class="language-python">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedNode</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        self.value = value
        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>      

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.value
</code></pre>
<p>Linked List -&gt; It is a collection of nodes arranged in a linear order.</p>
<ul>
<li>Head: A reference to the first node in the list.</li>
<li>Tail: A reference to the last node in the list (in some implementations). (not mandatory)</li>
<li>Size: The number of nodes in the list. (not mandatory)</li>
</ul>
<p>Types:</p>
<ol>
<li>
<p>Singly Linked List:</p>
<ul>
<li>Structure: Each node contains data and references to the next node.</li>
<li>Usage: Simple to implement and efficient for operations that primarily involve traversing the list in one direction.</li>
<li>Example: A list of items to be processed sequentially.</li>
</ul>
</li>
<li>
<p>Doubly Linked List:</p>
<ul>
<li>Structure: Each node contains data, a reference to the next node, and a reference to the previous node.</li>
<li>Usage: More flexible than singly linked lists in such a way that it can traverse in both ways of direction. Useful for applications in which there's a frequent need to be able to add/remove nodes at either end or to traverse backward.</li>
<li>Example: Making a web browser's forward and backward navigation.</li>
</ul>
</li>
<li>
<p>Circular Linked List:</p>
<ul>
<li>Structure: The last node points back to the first node, so we have a circle.</li>
<li>Usage: Useful in application programs where the list is to be accessed circularly, for example, in round-robin scheduling.</li>
<li>Example: Managing a playlist of songs that should repeat.</li>
</ul>
</li>
<li>
<p>Circular Doubly Linked List:</p>
<ul>
<li>Structure: Circular list with some features of a doubly linked list. Every node points to both the next and previous node. The list forms a circle.</li>
<li>Usage: Useful where one needs the flexibility of a doubly linked list with the circular structure, allowing efficient traversal and modification from any point in the list.</li>
<li>Example: The Implementation of Circular Buffer.</li>
</ul>
</li>
</ol>
<h1 id="question-2">Question 2</h1>
<p><strong>Q2 -- Give the time complexity of the following operations and explain briefly why that is the case.</strong></p>
<ol>
<li>Insert at beginning</li>
<li>Insert at end</li>
<li>Delete from beginning</li>
<li>Delete from end</li>
<li>Search a value</li>
<li>Find the index of a value</li>
</ol>
<p><strong>Answer 2:</strong></p>
<p><strong>1. Insert at beginning</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_at_beginning</span>(<span class="hljs-params">self, value</span>):
        current_head = self.head
        new_node = LinkedNode(value)
        new_node.<span class="hljs-built_in">next</span> = current_head
        self.head = new_node
</code></pre>
<p><strong>Time Complexity: -</strong></p>
<p><code>O(1)</code> -&gt; We just need to create a new node and update its next pointer to the current head, then update the head to this new node.</p>
<p><strong>2. Insert at end</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert_at_end</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self) == <span class="hljs-number">0</span>:
            new_node = LinkedNode(value)
            self.head = new_node
        <span class="hljs-keyword">else</span>:
            current_node = self.head
            <span class="hljs-keyword">while</span> current_node:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_node.<span class="hljs-built_in">next</span>:
                    current_tail = current_node
                    new_node = LinkedNode(value)
                    current_tail.<span class="hljs-built_in">next</span> = new_node
                    new_node.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
                    <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">else</span>:
                    current_node = current_node.<span class="hljs-built_in">next</span>
</code></pre>
<p><strong>Time Complexity: -</strong></p>
<p><code>O(n)</code> -&gt; We just need to traverse the entire list to find the last node, then update its next pointer to the new node.</p>
<p><strong>3. Delete from beginning</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_from_beginning</span>(<span class="hljs-params">self</span>):
        self.head = self.head.<span class="hljs-built_in">next</span>
</code></pre>
<p><strong>Time Complexity: -</strong></p>
<p><code>O(1)</code> -&gt;  We just need to update the head to the next node in the list.</p>
<p><strong>4. Delete from end</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_from_end</span>(<span class="hljs-params">self</span>):
        current_node = self.head
        <span class="hljs-keyword">while</span> current_node:
            <span class="hljs-keyword">if</span> current_node.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:
                current_node.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span>:
                current_node = current_node.<span class="hljs-built_in">next</span>
</code></pre>
<p><strong>Time Complexity: -</strong></p>
<p><code>O(n)</code> -&gt; We just need to traverse the list to find the second-to-last node to update its next pointer to null.</p>
<p><strong>5. Search a value</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">search_value</span>(<span class="hljs-params">self, value</span>):
        current_node = self.head
        current_node_index = <span class="hljs-number">0</span> 
        <span class="hljs-keyword">while</span> current_node:
            <span class="hljs-keyword">if</span> current_node.value == value:
                <span class="hljs-keyword">return</span> current_node_index
            <span class="hljs-keyword">else</span>:
                current_node = current_node.<span class="hljs-built_in">next</span>
                current_node_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
</code></pre>
<p>Time Complexity: -</p>
<p><code>O(n)</code> -&gt; In the worst case, we may need to traverse the entire list to find the value.</p>
<p><strong>6. Find the index of a value</strong></p>
<pre><code class="language-python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_index</span>(<span class="hljs-params">self, value</span>):
        current_node = self.head
        index = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> current_node:
            <span class="hljs-keyword">if</span> current_node.value == value:
                <span class="hljs-keyword">return</span> index
            current_node = current_node.<span class="hljs-built_in">next</span>
            index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> 
</code></pre>
<p><strong>Time Complexity: -</strong></p>
<p><code>O(n)</code> -&gt; Similar to search, we may need to traverse the entire list to find the index of the value.</p>
<h1 id="question-3">Question 3</h1>
<p><strong>Q3 -- On a piece of paper, trace the steps of inserting the value 66 at the third index of the linked list with values [1, 2, 3, 4, 5]. Be creative!</strong></p>
<p><strong>Answer 3:</strong></p>
<p><img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720053504/JPEG_image-4BE3-BADB-1B-0_tobowb.jpg" alt="Description"></p>
<h1 id="question-4">Question 4</h1>
<p><strong>Q4 -- On a piece of paper, trace the steps for reversing the linked list [1, 2, 3, 4, 5]. First, explain all the variables that are initialized and why you need them. Then, step through the algorithm and draw the linked list, and show all the variables at each step. Make sure to point out how the head updates at each step and what happens at the end.</strong></p>
<p><strong>Answer 4:</strong></p>
<p><img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720010180/JPEG_image-4A4B-8FEF-9E-0_h1nof7.jpg" alt="Description"></p>
<p><img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720010179/JPEG_image-4477-A7B9-14-0_t3yjwp.jpg" alt="Description"></p>
<h1 id="question-5">Question 5</h1>
<p><strong>Q5 -- On a piece of paper, trace the steps for detecting a cycle in the linked list [1, 2, 3, 4, 5], where 5 points back to 3. First, explain all the variables that are initialized and why you need them. Then, step through the algorithm and draw the linked list, and show all the variables at each step. Also, Explain what &quot;while slow and fast and fast.next&quot; is doing. Explain what happens when there is no cycle in a linked list. Explain how fast and slow traversing detects a cycle.</strong></p>
<p><strong>Answer 5:</strong></p>
<p><strong>Variables Initialization</strong></p>
<ul>
<li>slow: This pointer moves one step at a time.</li>
<li>fast: This pointer moves two steps at a time.</li>
<li>head: The starting node of the list.</li>
</ul>
<p>These pointers help in determining if a cycle exists by comparing their positions as they traverse the list.</p>
<p>Initial State</p>
<p>List: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 3 (cycle)</p>
<ul>
<li>slow: head (initially points to node 1)</li>
<li>fast: head (initially points to node 1)</li>
<li>Explanation of while slow and fast and fast.next</li>
</ul>
<p>The condition while slow and fast and fast.next ensures that the traversal continues as long as:</p>
<ul>
<li>slow is not None.</li>
<li>fast is not None.</li>
<li>fast.next is not None.</li>
</ul>
<p>If any of these conditions fail, it means we've reached the end of a non-cyclic list, and there is no cycle.</p>
<p><strong>Explanation</strong></p>
<p><strong>1. while slow and fast and fast.next:</strong> This loop continues as long as slow, fast, and fast.next are not None. If either fast or fast.next becomes None, it means there is no cycle (since fast can reach the end of the list).</p>
<p><strong>2. No cycle:</strong> If the loop exits because fast or fast.next becomes None, there is no cycle in the list.</p>
<p><strong>3. Cycle detection:</strong> When slow and fast meet, it means that fast has caught up to slow within the cycle, confirming the presence of a cycle.</p>
<p><img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720012227/JPEG_image-4616-A1DA-79-0_dys3gd.jpg" alt="Description"></p>
<h1 id="question-6">Question 6</h1>
<p><strong>Q6 -- On a piece of paper, trace the steps for deleting a value from a linked list. The linked list is [1, 2, 3, 4, 5], and delete the value 3. First, explain all the variables that are initialized and why you need them. Then, step through the algorithm and draw the linked list, and show all the variables at each step.</strong></p>
<p><strong>Answer 6:</strong></p>
<p>Variables Initialization</p>
<ul>
<li>current_node: This pointer is used to traverse the linked list. It starts at the head of the list.</li>
<li>previous_node: This pointer keeps track of the node before current_node. It starts as None because there is no previous node for the head.</li>
</ul>
<p>Algorithm for Deleting a Value</p>
<ul>
<li>Traverse the list using current_node.</li>
<li>If current_node.value matches the value to be deleted (3 in this case):</li>
<li>If previous_node is None, it means we are deleting the head node. Update self.head to current_node.next.
Otherwise, set previous_node.next to current_node.next to remove current_node from the list.</li>
<li>If no match is found and the end of the list is reached, return -1.</li>
</ul>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_value</span>(<span class="hljs-params">self, value</span>):
    current_node = self.head
    previous_node = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">while</span> current_node:
        <span class="hljs-keyword">if</span> current_node.value == value:
            <span class="hljs-keyword">if</span> previous_node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                self.head = self.head.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">else</span>:
                previous_node.<span class="hljs-built_in">next</span> = current_node.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">return</span> current_node.value
        <span class="hljs-keyword">else</span>:
            previous_node = current_node
            current_node = current_node.<span class="hljs-built_in">next</span>
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>

</code></pre>
<p><img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720013558/JPEG_image-4056-82E0-B4-0_zsvw62.jpg" alt="Description"></p>
<hr/>
            
            
        </body>
        </html>