<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Data Structures and Algorithms with Python - Video Assignment - 3</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="data-structures-and-algorithms-with-python---video-assignment---3">Data Structures and Algorithms with Python - Video Assignment - 3</h1>
<p><strong>CDA 500</strong>
<strong>Vaibhav Bansal - 50560484</strong></p>
<h2 id="video-link-1-stack">Video Link 1 (STACK):</h2>
<p><a href="https://buffalo.box.com/s/gy1cg9pr7r759quado8jjybftosu5zlp">https://buffalo.box.com/s/gy1cg9pr7r759quado8jjybftosu5zlp</a></p>
<h2 id="questions">Questions</h2>
<p><strong>Ques 1  Explain what a Stack is, covering its basic functionalities such as push, pop, and read/peek. Discuss the time complexities associated with implementing a stack using a list versus a linked list. Explain the reasons behind the differences in time complexities.</strong></p>
<p><strong>Solution 1</strong></p>
<p>A Stack is a linear data structure that follows the Last In, First Out (LIFO) principle. This means that the last element added to the stack will be the first one to be removed.Stacks and queues are not new a data structure. Rather, they are simply arrays with restrictions. It is is these restrictions that makes them so elegant. They are elegant tools for handling temporary data. Temporary data is information that does not have any meaning after it is processed, so you can throw it away once you are done with it. Stacks and queues handle temporary data, but they have a special focus on the order in which the data is handled.</p>
<p>A stack stores data in the same way arrays do, except that they have three restrictions.</p>
<ul>
<li>Data can be inserted only at the end of a stack</li>
<li>Data can be deleted only from the end of a stack</li>
<li>Only the last element of a stack can be read</li>
</ul>
<p>The beginning of the stack is its bottom and the end of the stack is its top. Stacks are LIFO -- last in first out! A stack class is simply an interface that forces the users to interact the array in a limited ways. A stack class only allows reading the last element, appending to the list, and removing the last element from the list. A stack DOES NOT have to be built using a list, you can also use a linked list. Stack is considered an abstract data type because it is built on top of other built-it data structures.</p>
<p><strong>Basic Functionalities of a Stack</strong></p>
<ul>
<li><strong>Push:</strong> Add an element to the top of the stack.</li>
<li><strong>Pop:</strong> Remove and return the top element from the stack.</li>
<li><strong>Read/Peek:</strong> Return the top element without removing it from the stack.</li>
</ul>
<h2 id="using-list">Using List</h2>
<pre><code class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackList</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.stack = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, item</span>):
        self.stack.append(item)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():
            <span class="hljs-keyword">return</span> self.stack.pop()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack is empty&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():
            <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack is empty&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span>

<span class="hljs-comment"># Example usage</span>
stack = StackList()
stack.push(<span class="hljs-number">1</span>)
stack.push(<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(stack.peek())  <span class="hljs-comment"># Output: 2</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: 2</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: 1</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: Stack is empty</span>

</code></pre>
<p><strong>Time Complexities:</strong></p>
<ul>
<li><strong>Push:</strong> O(1) - Appending an element to the end of a list is an O(1) operation in most list implementations.</li>
<li><strong>Pop:</strong> O(1) - Removing the last element of the list is also O(1) as it involves simply shortening the list.</li>
<li><strong>Peek:</strong> O(1) - Accessing the last element of the list is an O(1) operation.</li>
</ul>
<h2 id="using-linked-list">Using Linked List</h2>
<pre><code class="language-python">
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        self.value = value
        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StackLinkedList</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.top = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, item</span>):
        new_node = Node(item)
        new_node.<span class="hljs-built_in">next</span> = self.top
        self.top = new_node

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():
            popped_value = self.top.value
            self.top = self.top.<span class="hljs-built_in">next</span>
            <span class="hljs-keyword">return</span> popped_value
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack is empty&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_empty():
            <span class="hljs-keyword">return</span> self.top.value
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Stack is empty&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> self.top <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># Example usage</span>
stack = StackLinkedList()
stack.push(<span class="hljs-number">1</span>)
stack.push(<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(stack.peek())  <span class="hljs-comment"># Output: 2</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: 2</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: 1</span>
<span class="hljs-built_in">print</span>(stack.pop())   <span class="hljs-comment"># Output: Stack is empty</span>

</code></pre>
<p><strong>Time Complexities:</strong></p>
<ul>
<li><strong>Push:</strong> O(1) - Adding an element to the top of the stack (head of the linked list) is O(1) because it involves updating a few pointers.</li>
<li><strong>Pop:</strong> O(1) - Removing the top element (head of the linked list) is O(1) as it requires reassigning the head pointer</li>
<li><strong>Peek:</strong> O(1) - Accessing the top element of the stack (head of the linked list) is O(1).</li>
</ul>
<p>Using a linked list, these operations are also constant time because we are only manipulating pointers and not traversing the list.</p>
<p><strong>Comparing Time Complexities</strong></p>
<p>Both list-based and linked list-based implementations of a stack provide O(1) time complexity for push, pop, and peek operations. The reason behind this is that both implementations involve only adding or removing elements from the top of the stack, which can be done in constant time.</p>
<p>However, there are some subtle differences in terms of space complexity and potential performance considerations:</p>
<p><strong>Space Complexity:</strong></p>
<ul>
<li>
<p><strong>List:</strong> The list-based stack may allocate more memory than necessary because lists in Python are dynamic arrays and may over-allocate to avoid frequent resizing.</p>
</li>
<li>
<p><strong>Linked List:</strong> The linked list-based stack uses exactly as much memory as needed for the elements plus a small overhead for the pointers.</p>
</li>
</ul>
<p><strong>Performance Considerations:</strong></p>
<ul>
<li>
<p><strong>List:</strong> Appending and popping from the end of the list is usually very fast due to contiguous memory allocation. However, if the list needs to resize (i.e., allocate a new, larger array and copy elements), it can occasionally incur a higher cost.</p>
</li>
<li>
<p><strong>Linked List:</strong> Operations are guaranteed to be O(1) because there is no resizing, but the overhead of managing the pointers and potentially higher memory usage for small elements can make it slightly less efficient in terms of raw performance.</p>
</li>
</ul>
<p>In conclusion, while both implementations offer O(1) time complexity for the primary stack operations, the choice between using a list and a linked list may depend on specific use cases, memory considerations, and language-specific performance characteristics.</p>
<p><strong>Ques 2 Use visual aids to demonstrate how a stack can be utilized as a linter and provide an explanation of the code that achieves the linting functionality. Present three scenarios:</strong></p>
<ul>
<li>
<p><strong>a. No mismatch</strong></p>
</li>
<li>
<p><strong>b. Missing closing brace, which could be any of the following: ]}),]}</strong></p>
</li>
<li>
<p><strong>c. Missing opening brace, which could be any of the following: ([{</strong></p>
</li>
</ul>
<p><strong>Solution 2</strong></p>
<p>A stack can be used effectively to check for balanced parentheses (including curly braces and square brackets) in a string. This is a common linting task, often used in programming languages to ensure that all opening brackets have corresponding closing brackets in the correct order.</p>
<p><strong>Linting Scenarios</strong></p>
<ul>
<li><strong>No Mismatch:</strong> The string has perfectly matched parentheses.</li>
<li><strong>Missing Closing Brace:</strong> The string has one or more opening braces without corresponding closing braces.</li>
<li><strong>Missing Opening Brace:</strong> The string has one or more closing braces without corresponding opening braces.</li>
</ul>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lint_parentheses</span>(<span class="hljs-params">input_string</span>):
    stack = []
    opening_braces = <span class="hljs-string">&quot;({[&quot;</span>
    closing_braces = <span class="hljs-string">&quot;)}]&quot;</span>
    matches = {<span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;}&#x27;</span>: <span class="hljs-string">&#x27;{&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>}

    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> input_string:
        <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> opening_braces:
            stack.append(char)
        <span class="hljs-keyword">elif</span> char <span class="hljs-keyword">in</span> closing_braces:
            <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] == matches[char]:
                stack.pop()
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Error: Unmatched closing brace &#x27;<span class="hljs-subst">{char}</span>&#x27;&quot;</span>
    
    <span class="hljs-keyword">if</span> stack:
        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Error: Unmatched opening brace &#x27;<span class="hljs-subst">{stack[-<span class="hljs-number">1</span>]}</span>&#x27;&quot;</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No mismatch&quot;</span>

<span class="hljs-comment"># Example strings for demonstration</span>
example_1 = <span class="hljs-string">&quot;{[()]}&quot;</span>       <span class="hljs-comment"># No mismatch</span>
example_2 = <span class="hljs-string">&quot;{[()]&quot;</span>        <span class="hljs-comment"># Missing closing brace</span>
example_3 = <span class="hljs-string">&quot;{[())]}&quot;</span>      <span class="hljs-comment"># Missing opening brace</span>

<span class="hljs-comment"># Results</span>
<span class="hljs-built_in">print</span>(lint_parentheses(example_1))  <span class="hljs-comment"># No mismatch</span>
<span class="hljs-built_in">print</span>(lint_parentheses(example_2))  <span class="hljs-comment"># Error: Unmatched opening brace &#x27;{&#x27;</span>
<span class="hljs-built_in">print</span>(lint_parentheses(example_3))  <span class="hljs-comment"># Error: Unmatched closing brace &#x27;)&#x27;</span>

</code></pre>
<h2 id="visual-representation">Visual Representation</h2>
<img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720488484/JPEG_image-4273-AA55-80-0_u3huwd.jpg" width="60%"/>
<img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720488484/JPEG_image-424B-BDC1-95-0_pyzttu.jpg" width="60%"/>
<img src="https://res.cloudinary.com/vaibhav-codexpress/image/upload/v1720488484/JPEG_image-47B9-B76C-EC-0_ahannw.jpg" width="60%"/>

            
            
        </body>
        </html>